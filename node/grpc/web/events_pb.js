/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var block_pb = require('./block_pb.js');
var amount_pb = require('./amount_pb.js');
var transaction_pb = require('./transaction_pb.js');
var invoke_script_result_pb = require('./invoke_script_result_pb.js');
goog.exportSymbol('proto.zb.events.BlockchainUpdated', null, global);
goog.exportSymbol('proto.zb.events.BlockchainUpdated.Append', null, global);
goog.exportSymbol('proto.zb.events.BlockchainUpdated.Append.BlockAppend', null, global);
goog.exportSymbol('proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend', null, global);
goog.exportSymbol('proto.zb.events.BlockchainUpdated.Rollback', null, global);
goog.exportSymbol('proto.zb.events.BlockchainUpdated.Rollback.RollbackType', null, global);
goog.exportSymbol('proto.zb.events.StateUpdate', null, global);
goog.exportSymbol('proto.zb.events.StateUpdate.AssetDetails', null, global);
goog.exportSymbol('proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo', null, global);
goog.exportSymbol('proto.zb.events.StateUpdate.AssetInfo', null, global);
goog.exportSymbol('proto.zb.events.StateUpdate.AssetStateUpdate', null, global);
goog.exportSymbol('proto.zb.events.StateUpdate.BalanceUpdate', null, global);
goog.exportSymbol('proto.zb.events.StateUpdate.DataEntryUpdate', null, global);
goog.exportSymbol('proto.zb.events.StateUpdate.LeaseUpdate', null, global);
goog.exportSymbol('proto.zb.events.StateUpdate.LeaseUpdate.LeaseStatus', null, global);
goog.exportSymbol('proto.zb.events.StateUpdate.LeasingUpdate', null, global);
goog.exportSymbol('proto.zb.events.TransactionMetadata', null, global);
goog.exportSymbol('proto.zb.events.TransactionMetadata.InvokeScriptMetadata', null, global);
goog.exportSymbol('proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument', null, global);
goog.exportSymbol('proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List', null, global);
goog.exportSymbol('proto.zb.events.TransactionMetadata.LeaseMetadata', null, global);
goog.exportSymbol('proto.zb.events.TransactionMetadata.MassTransferMetadata', null, global);
goog.exportSymbol('proto.zb.events.TransactionMetadata.TransferMetadata', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.BlockchainUpdated = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.zb.events.BlockchainUpdated.repeatedFields_, proto.zb.events.BlockchainUpdated.oneofGroups_);
};
goog.inherits(proto.zb.events.BlockchainUpdated, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.BlockchainUpdated.displayName = 'proto.zb.events.BlockchainUpdated';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.zb.events.BlockchainUpdated.repeatedFields_ = [21];

/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.zb.events.BlockchainUpdated.oneofGroups_ = [[11,12]];

/**
 * @enum {number}
 */
proto.zb.events.BlockchainUpdated.UpdateCase = {
  UPDATE_NOT_SET: 0,
  APPEND: 11,
  ROLLBACK: 12
};

/**
 * @return {proto.zb.events.BlockchainUpdated.UpdateCase}
 */
proto.zb.events.BlockchainUpdated.prototype.getUpdateCase = function() {
  return /** @type {proto.zb.events.BlockchainUpdated.UpdateCase} */(jspb.Message.computeOneofCase(this, proto.zb.events.BlockchainUpdated.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.BlockchainUpdated.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.BlockchainUpdated.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.BlockchainUpdated} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.BlockchainUpdated.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.getId_asB64(),
    height: jspb.Message.getFieldWithDefault(msg, 2, 0),
    append: (f = msg.getAppend()) && proto.zb.events.BlockchainUpdated.Append.toObject(includeInstance, f),
    rollback: (f = msg.getRollback()) && proto.zb.events.BlockchainUpdated.Rollback.toObject(includeInstance, f),
    referencedAssetsList: jspb.Message.toObjectList(msg.getReferencedAssetsList(),
    proto.zb.events.StateUpdate.AssetInfo.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.BlockchainUpdated}
 */
proto.zb.events.BlockchainUpdated.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.BlockchainUpdated;
  return proto.zb.events.BlockchainUpdated.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.BlockchainUpdated} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.BlockchainUpdated}
 */
proto.zb.events.BlockchainUpdated.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setHeight(value);
      break;
    case 11:
      var value = new proto.zb.events.BlockchainUpdated.Append;
      reader.readMessage(value,proto.zb.events.BlockchainUpdated.Append.deserializeBinaryFromReader);
      msg.setAppend(value);
      break;
    case 12:
      var value = new proto.zb.events.BlockchainUpdated.Rollback;
      reader.readMessage(value,proto.zb.events.BlockchainUpdated.Rollback.deserializeBinaryFromReader);
      msg.setRollback(value);
      break;
    case 21:
      var value = new proto.zb.events.StateUpdate.AssetInfo;
      reader.readMessage(value,proto.zb.events.StateUpdate.AssetInfo.deserializeBinaryFromReader);
      msg.addReferencedAssets(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.BlockchainUpdated.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.BlockchainUpdated.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.BlockchainUpdated} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.BlockchainUpdated.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getHeight();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getAppend();
  if (f != null) {
    writer.writeMessage(
      11,
      f,
      proto.zb.events.BlockchainUpdated.Append.serializeBinaryToWriter
    );
  }
  f = message.getRollback();
  if (f != null) {
    writer.writeMessage(
      12,
      f,
      proto.zb.events.BlockchainUpdated.Rollback.serializeBinaryToWriter
    );
  }
  f = message.getReferencedAssetsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      21,
      f,
      proto.zb.events.StateUpdate.AssetInfo.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.BlockchainUpdated.Append = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.zb.events.BlockchainUpdated.Append.repeatedFields_, proto.zb.events.BlockchainUpdated.Append.oneofGroups_);
};
goog.inherits(proto.zb.events.BlockchainUpdated.Append, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.BlockchainUpdated.Append.displayName = 'proto.zb.events.BlockchainUpdated.Append';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.zb.events.BlockchainUpdated.Append.repeatedFields_ = [3,4,12];

/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.zb.events.BlockchainUpdated.Append.oneofGroups_ = [[1,2]];

/**
 * @enum {number}
 */
proto.zb.events.BlockchainUpdated.Append.BodyCase = {
  BODY_NOT_SET: 0,
  BLOCK: 1,
  MICRO_BLOCK: 2
};

/**
 * @return {proto.zb.events.BlockchainUpdated.Append.BodyCase}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.getBodyCase = function() {
  return /** @type {proto.zb.events.BlockchainUpdated.Append.BodyCase} */(jspb.Message.computeOneofCase(this, proto.zb.events.BlockchainUpdated.Append.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.BlockchainUpdated.Append.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.BlockchainUpdated.Append} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.BlockchainUpdated.Append.toObject = function(includeInstance, msg) {
  var f, obj = {
    block: (f = msg.getBlock()) && proto.zb.events.BlockchainUpdated.Append.BlockAppend.toObject(includeInstance, f),
    microBlock: (f = msg.getMicroBlock()) && proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.toObject(includeInstance, f),
    transactionIdsList: msg.getTransactionIdsList_asB64(),
    transactionsMetadataList: jspb.Message.toObjectList(msg.getTransactionsMetadataList(),
    proto.zb.events.TransactionMetadata.toObject, includeInstance),
    stateUpdate: (f = msg.getStateUpdate()) && proto.zb.events.StateUpdate.toObject(includeInstance, f),
    transactionStateUpdatesList: jspb.Message.toObjectList(msg.getTransactionStateUpdatesList(),
    proto.zb.events.StateUpdate.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.BlockchainUpdated.Append}
 */
proto.zb.events.BlockchainUpdated.Append.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.BlockchainUpdated.Append;
  return proto.zb.events.BlockchainUpdated.Append.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.BlockchainUpdated.Append} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.BlockchainUpdated.Append}
 */
proto.zb.events.BlockchainUpdated.Append.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.zb.events.BlockchainUpdated.Append.BlockAppend;
      reader.readMessage(value,proto.zb.events.BlockchainUpdated.Append.BlockAppend.deserializeBinaryFromReader);
      msg.setBlock(value);
      break;
    case 2:
      var value = new proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend;
      reader.readMessage(value,proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.deserializeBinaryFromReader);
      msg.setMicroBlock(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addTransactionIds(value);
      break;
    case 4:
      var value = new proto.zb.events.TransactionMetadata;
      reader.readMessage(value,proto.zb.events.TransactionMetadata.deserializeBinaryFromReader);
      msg.addTransactionsMetadata(value);
      break;
    case 11:
      var value = new proto.zb.events.StateUpdate;
      reader.readMessage(value,proto.zb.events.StateUpdate.deserializeBinaryFromReader);
      msg.setStateUpdate(value);
      break;
    case 12:
      var value = new proto.zb.events.StateUpdate;
      reader.readMessage(value,proto.zb.events.StateUpdate.deserializeBinaryFromReader);
      msg.addTransactionStateUpdates(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.BlockchainUpdated.Append.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.BlockchainUpdated.Append} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.BlockchainUpdated.Append.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBlock();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.zb.events.BlockchainUpdated.Append.BlockAppend.serializeBinaryToWriter
    );
  }
  f = message.getMicroBlock();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.serializeBinaryToWriter
    );
  }
  f = message.getTransactionIdsList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      3,
      f
    );
  }
  f = message.getTransactionsMetadataList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.zb.events.TransactionMetadata.serializeBinaryToWriter
    );
  }
  f = message.getStateUpdate();
  if (f != null) {
    writer.writeMessage(
      11,
      f,
      proto.zb.events.StateUpdate.serializeBinaryToWriter
    );
  }
  f = message.getTransactionStateUpdatesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      12,
      f,
      proto.zb.events.StateUpdate.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.BlockchainUpdated.Append.BlockAppend = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.zb.events.BlockchainUpdated.Append.BlockAppend, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.BlockchainUpdated.Append.BlockAppend.displayName = 'proto.zb.events.BlockchainUpdated.Append.BlockAppend';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.BlockchainUpdated.Append.BlockAppend.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.BlockchainUpdated.Append.BlockAppend.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.BlockchainUpdated.Append.BlockAppend} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.BlockchainUpdated.Append.BlockAppend.toObject = function(includeInstance, msg) {
  var f, obj = {
    block: (f = msg.getBlock()) && block_pb.Block.toObject(includeInstance, f),
    updatedWavesAmount: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.BlockchainUpdated.Append.BlockAppend}
 */
proto.zb.events.BlockchainUpdated.Append.BlockAppend.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.BlockchainUpdated.Append.BlockAppend;
  return proto.zb.events.BlockchainUpdated.Append.BlockAppend.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.BlockchainUpdated.Append.BlockAppend} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.BlockchainUpdated.Append.BlockAppend}
 */
proto.zb.events.BlockchainUpdated.Append.BlockAppend.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new block_pb.Block;
      reader.readMessage(value,block_pb.Block.deserializeBinaryFromReader);
      msg.setBlock(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setUpdatedWavesAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.BlockchainUpdated.Append.BlockAppend.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.BlockchainUpdated.Append.BlockAppend.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.BlockchainUpdated.Append.BlockAppend} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.BlockchainUpdated.Append.BlockAppend.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBlock();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      block_pb.Block.serializeBinaryToWriter
    );
  }
  f = message.getUpdatedWavesAmount();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * optional zb.Block block = 1;
 * @return {?proto.zb.Block}
 */
proto.zb.events.BlockchainUpdated.Append.BlockAppend.prototype.getBlock = function() {
  return /** @type{?proto.zb.Block} */ (
    jspb.Message.getWrapperField(this, block_pb.Block, 1));
};


/** @param {?proto.zb.Block|undefined} value */
proto.zb.events.BlockchainUpdated.Append.BlockAppend.prototype.setBlock = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.zb.events.BlockchainUpdated.Append.BlockAppend.prototype.clearBlock = function() {
  this.setBlock(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.BlockchainUpdated.Append.BlockAppend.prototype.hasBlock = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional int64 updated_waves_amount = 2;
 * @return {number}
 */
proto.zb.events.BlockchainUpdated.Append.BlockAppend.prototype.getUpdatedWavesAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.zb.events.BlockchainUpdated.Append.BlockAppend.prototype.setUpdatedWavesAmount = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.displayName = 'proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.toObject = function(includeInstance, msg) {
  var f, obj = {
    microBlock: (f = msg.getMicroBlock()) && block_pb.SignedMicroBlock.toObject(includeInstance, f),
    updatedTransactionsRoot: msg.getUpdatedTransactionsRoot_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend}
 */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend;
  return proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend}
 */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new block_pb.SignedMicroBlock;
      reader.readMessage(value,block_pb.SignedMicroBlock.deserializeBinaryFromReader);
      msg.setMicroBlock(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setUpdatedTransactionsRoot(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMicroBlock();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      block_pb.SignedMicroBlock.serializeBinaryToWriter
    );
  }
  f = message.getUpdatedTransactionsRoot_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional zb.SignedMicroBlock micro_block = 1;
 * @return {?proto.zb.SignedMicroBlock}
 */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.prototype.getMicroBlock = function() {
  return /** @type{?proto.zb.SignedMicroBlock} */ (
    jspb.Message.getWrapperField(this, block_pb.SignedMicroBlock, 1));
};


/** @param {?proto.zb.SignedMicroBlock|undefined} value */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.prototype.setMicroBlock = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.prototype.clearMicroBlock = function() {
  this.setMicroBlock(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.prototype.hasMicroBlock = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes updated_transactions_root = 2;
 * @return {string}
 */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.prototype.getUpdatedTransactionsRoot = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes updated_transactions_root = 2;
 * This is a type-conversion wrapper around `getUpdatedTransactionsRoot()`
 * @return {string}
 */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.prototype.getUpdatedTransactionsRoot_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getUpdatedTransactionsRoot()));
};


/**
 * optional bytes updated_transactions_root = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getUpdatedTransactionsRoot()`
 * @return {!Uint8Array}
 */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.prototype.getUpdatedTransactionsRoot_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getUpdatedTransactionsRoot()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend.prototype.setUpdatedTransactionsRoot = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional BlockAppend block = 1;
 * @return {?proto.zb.events.BlockchainUpdated.Append.BlockAppend}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.getBlock = function() {
  return /** @type{?proto.zb.events.BlockchainUpdated.Append.BlockAppend} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.BlockchainUpdated.Append.BlockAppend, 1));
};


/** @param {?proto.zb.events.BlockchainUpdated.Append.BlockAppend|undefined} value */
proto.zb.events.BlockchainUpdated.Append.prototype.setBlock = function(value) {
  jspb.Message.setOneofWrapperField(this, 1, proto.zb.events.BlockchainUpdated.Append.oneofGroups_[0], value);
};


proto.zb.events.BlockchainUpdated.Append.prototype.clearBlock = function() {
  this.setBlock(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.hasBlock = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional MicroBlockAppend micro_block = 2;
 * @return {?proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.getMicroBlock = function() {
  return /** @type{?proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend, 2));
};


/** @param {?proto.zb.events.BlockchainUpdated.Append.MicroBlockAppend|undefined} value */
proto.zb.events.BlockchainUpdated.Append.prototype.setMicroBlock = function(value) {
  jspb.Message.setOneofWrapperField(this, 2, proto.zb.events.BlockchainUpdated.Append.oneofGroups_[0], value);
};


proto.zb.events.BlockchainUpdated.Append.prototype.clearMicroBlock = function() {
  this.setMicroBlock(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.hasMicroBlock = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * repeated bytes transaction_ids = 3;
 * @return {!Array<string>}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.getTransactionIdsList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 3));
};


/**
 * repeated bytes transaction_ids = 3;
 * This is a type-conversion wrapper around `getTransactionIdsList()`
 * @return {!Array<string>}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.getTransactionIdsList_asB64 = function() {
  return /** @type {!Array<string>} */ (jspb.Message.bytesListAsB64(
      this.getTransactionIdsList()));
};


/**
 * repeated bytes transaction_ids = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTransactionIdsList()`
 * @return {!Array<!Uint8Array>}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.getTransactionIdsList_asU8 = function() {
  return /** @type {!Array<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getTransactionIdsList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.zb.events.BlockchainUpdated.Append.prototype.setTransactionIdsList = function(value) {
  jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.zb.events.BlockchainUpdated.Append.prototype.addTransactionIds = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


proto.zb.events.BlockchainUpdated.Append.prototype.clearTransactionIdsList = function() {
  this.setTransactionIdsList([]);
};


/**
 * repeated TransactionMetadata transactions_metadata = 4;
 * @return {!Array<!proto.zb.events.TransactionMetadata>}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.getTransactionsMetadataList = function() {
  return /** @type{!Array<!proto.zb.events.TransactionMetadata>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.zb.events.TransactionMetadata, 4));
};


/** @param {!Array<!proto.zb.events.TransactionMetadata>} value */
proto.zb.events.BlockchainUpdated.Append.prototype.setTransactionsMetadataList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.zb.events.TransactionMetadata=} opt_value
 * @param {number=} opt_index
 * @return {!proto.zb.events.TransactionMetadata}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.addTransactionsMetadata = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.zb.events.TransactionMetadata, opt_index);
};


proto.zb.events.BlockchainUpdated.Append.prototype.clearTransactionsMetadataList = function() {
  this.setTransactionsMetadataList([]);
};


/**
 * optional StateUpdate state_update = 11;
 * @return {?proto.zb.events.StateUpdate}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.getStateUpdate = function() {
  return /** @type{?proto.zb.events.StateUpdate} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.StateUpdate, 11));
};


/** @param {?proto.zb.events.StateUpdate|undefined} value */
proto.zb.events.BlockchainUpdated.Append.prototype.setStateUpdate = function(value) {
  jspb.Message.setWrapperField(this, 11, value);
};


proto.zb.events.BlockchainUpdated.Append.prototype.clearStateUpdate = function() {
  this.setStateUpdate(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.hasStateUpdate = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * repeated StateUpdate transaction_state_updates = 12;
 * @return {!Array<!proto.zb.events.StateUpdate>}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.getTransactionStateUpdatesList = function() {
  return /** @type{!Array<!proto.zb.events.StateUpdate>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.zb.events.StateUpdate, 12));
};


/** @param {!Array<!proto.zb.events.StateUpdate>} value */
proto.zb.events.BlockchainUpdated.Append.prototype.setTransactionStateUpdatesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 12, value);
};


/**
 * @param {!proto.zb.events.StateUpdate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.zb.events.StateUpdate}
 */
proto.zb.events.BlockchainUpdated.Append.prototype.addTransactionStateUpdates = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 12, opt_value, proto.zb.events.StateUpdate, opt_index);
};


proto.zb.events.BlockchainUpdated.Append.prototype.clearTransactionStateUpdatesList = function() {
  this.setTransactionStateUpdatesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.BlockchainUpdated.Rollback = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.zb.events.BlockchainUpdated.Rollback.repeatedFields_, null);
};
goog.inherits(proto.zb.events.BlockchainUpdated.Rollback, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.BlockchainUpdated.Rollback.displayName = 'proto.zb.events.BlockchainUpdated.Rollback';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.zb.events.BlockchainUpdated.Rollback.repeatedFields_ = [2,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.BlockchainUpdated.Rollback.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.BlockchainUpdated.Rollback.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.BlockchainUpdated.Rollback} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.BlockchainUpdated.Rollback.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getFieldWithDefault(msg, 1, 0),
    removedTransactionIdsList: msg.getRemovedTransactionIdsList_asB64(),
    removedBlocksList: jspb.Message.toObjectList(msg.getRemovedBlocksList(),
    block_pb.Block.toObject, includeInstance),
    rollbackStateUpdate: (f = msg.getRollbackStateUpdate()) && proto.zb.events.StateUpdate.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.BlockchainUpdated.Rollback}
 */
proto.zb.events.BlockchainUpdated.Rollback.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.BlockchainUpdated.Rollback;
  return proto.zb.events.BlockchainUpdated.Rollback.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.BlockchainUpdated.Rollback} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.BlockchainUpdated.Rollback}
 */
proto.zb.events.BlockchainUpdated.Rollback.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.zb.events.BlockchainUpdated.Rollback.RollbackType} */ (reader.readEnum());
      msg.setType(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addRemovedTransactionIds(value);
      break;
    case 3:
      var value = new block_pb.Block;
      reader.readMessage(value,block_pb.Block.deserializeBinaryFromReader);
      msg.addRemovedBlocks(value);
      break;
    case 4:
      var value = new proto.zb.events.StateUpdate;
      reader.readMessage(value,proto.zb.events.StateUpdate.deserializeBinaryFromReader);
      msg.setRollbackStateUpdate(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.BlockchainUpdated.Rollback.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.BlockchainUpdated.Rollback.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.BlockchainUpdated.Rollback} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.BlockchainUpdated.Rollback.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getType();
  if (f !== 0.0) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getRemovedTransactionIdsList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      2,
      f
    );
  }
  f = message.getRemovedBlocksList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      block_pb.Block.serializeBinaryToWriter
    );
  }
  f = message.getRollbackStateUpdate();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.zb.events.StateUpdate.serializeBinaryToWriter
    );
  }
};


/**
 * @enum {number}
 */
proto.zb.events.BlockchainUpdated.Rollback.RollbackType = {
  BLOCK: 0,
  MICROBLOCK: 1
};

/**
 * optional RollbackType type = 1;
 * @return {!proto.zb.events.BlockchainUpdated.Rollback.RollbackType}
 */
proto.zb.events.BlockchainUpdated.Rollback.prototype.getType = function() {
  return /** @type {!proto.zb.events.BlockchainUpdated.Rollback.RollbackType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.zb.events.BlockchainUpdated.Rollback.RollbackType} value */
proto.zb.events.BlockchainUpdated.Rollback.prototype.setType = function(value) {
  jspb.Message.setProto3EnumField(this, 1, value);
};


/**
 * repeated bytes removed_transaction_ids = 2;
 * @return {!Array<string>}
 */
proto.zb.events.BlockchainUpdated.Rollback.prototype.getRemovedTransactionIdsList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * repeated bytes removed_transaction_ids = 2;
 * This is a type-conversion wrapper around `getRemovedTransactionIdsList()`
 * @return {!Array<string>}
 */
proto.zb.events.BlockchainUpdated.Rollback.prototype.getRemovedTransactionIdsList_asB64 = function() {
  return /** @type {!Array<string>} */ (jspb.Message.bytesListAsB64(
      this.getRemovedTransactionIdsList()));
};


/**
 * repeated bytes removed_transaction_ids = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRemovedTransactionIdsList()`
 * @return {!Array<!Uint8Array>}
 */
proto.zb.events.BlockchainUpdated.Rollback.prototype.getRemovedTransactionIdsList_asU8 = function() {
  return /** @type {!Array<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getRemovedTransactionIdsList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.zb.events.BlockchainUpdated.Rollback.prototype.setRemovedTransactionIdsList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.zb.events.BlockchainUpdated.Rollback.prototype.addRemovedTransactionIds = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.zb.events.BlockchainUpdated.Rollback.prototype.clearRemovedTransactionIdsList = function() {
  this.setRemovedTransactionIdsList([]);
};


/**
 * repeated zb.Block removed_blocks = 3;
 * @return {!Array<!proto.zb.Block>}
 */
proto.zb.events.BlockchainUpdated.Rollback.prototype.getRemovedBlocksList = function() {
  return /** @type{!Array<!proto.zb.Block>} */ (
    jspb.Message.getRepeatedWrapperField(this, block_pb.Block, 3));
};


/** @param {!Array<!proto.zb.Block>} value */
proto.zb.events.BlockchainUpdated.Rollback.prototype.setRemovedBlocksList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.zb.Block=} opt_value
 * @param {number=} opt_index
 * @return {!proto.zb.Block}
 */
proto.zb.events.BlockchainUpdated.Rollback.prototype.addRemovedBlocks = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.zb.Block, opt_index);
};


proto.zb.events.BlockchainUpdated.Rollback.prototype.clearRemovedBlocksList = function() {
  this.setRemovedBlocksList([]);
};


/**
 * optional StateUpdate rollback_state_update = 4;
 * @return {?proto.zb.events.StateUpdate}
 */
proto.zb.events.BlockchainUpdated.Rollback.prototype.getRollbackStateUpdate = function() {
  return /** @type{?proto.zb.events.StateUpdate} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.StateUpdate, 4));
};


/** @param {?proto.zb.events.StateUpdate|undefined} value */
proto.zb.events.BlockchainUpdated.Rollback.prototype.setRollbackStateUpdate = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.zb.events.BlockchainUpdated.Rollback.prototype.clearRollbackStateUpdate = function() {
  this.setRollbackStateUpdate(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.BlockchainUpdated.Rollback.prototype.hasRollbackStateUpdate = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bytes id = 1;
 * @return {string}
 */
proto.zb.events.BlockchainUpdated.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes id = 1;
 * This is a type-conversion wrapper around `getId()`
 * @return {string}
 */
proto.zb.events.BlockchainUpdated.prototype.getId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getId()));
};


/**
 * optional bytes id = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getId()`
 * @return {!Uint8Array}
 */
proto.zb.events.BlockchainUpdated.prototype.getId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getId()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.BlockchainUpdated.prototype.setId = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional int32 height = 2;
 * @return {number}
 */
proto.zb.events.BlockchainUpdated.prototype.getHeight = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.zb.events.BlockchainUpdated.prototype.setHeight = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional Append append = 11;
 * @return {?proto.zb.events.BlockchainUpdated.Append}
 */
proto.zb.events.BlockchainUpdated.prototype.getAppend = function() {
  return /** @type{?proto.zb.events.BlockchainUpdated.Append} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.BlockchainUpdated.Append, 11));
};


/** @param {?proto.zb.events.BlockchainUpdated.Append|undefined} value */
proto.zb.events.BlockchainUpdated.prototype.setAppend = function(value) {
  jspb.Message.setOneofWrapperField(this, 11, proto.zb.events.BlockchainUpdated.oneofGroups_[0], value);
};


proto.zb.events.BlockchainUpdated.prototype.clearAppend = function() {
  this.setAppend(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.BlockchainUpdated.prototype.hasAppend = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional Rollback rollback = 12;
 * @return {?proto.zb.events.BlockchainUpdated.Rollback}
 */
proto.zb.events.BlockchainUpdated.prototype.getRollback = function() {
  return /** @type{?proto.zb.events.BlockchainUpdated.Rollback} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.BlockchainUpdated.Rollback, 12));
};


/** @param {?proto.zb.events.BlockchainUpdated.Rollback|undefined} value */
proto.zb.events.BlockchainUpdated.prototype.setRollback = function(value) {
  jspb.Message.setOneofWrapperField(this, 12, proto.zb.events.BlockchainUpdated.oneofGroups_[0], value);
};


proto.zb.events.BlockchainUpdated.prototype.clearRollback = function() {
  this.setRollback(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.BlockchainUpdated.prototype.hasRollback = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * repeated StateUpdate.AssetInfo referenced_assets = 21;
 * @return {!Array<!proto.zb.events.StateUpdate.AssetInfo>}
 */
proto.zb.events.BlockchainUpdated.prototype.getReferencedAssetsList = function() {
  return /** @type{!Array<!proto.zb.events.StateUpdate.AssetInfo>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.zb.events.StateUpdate.AssetInfo, 21));
};


/** @param {!Array<!proto.zb.events.StateUpdate.AssetInfo>} value */
proto.zb.events.BlockchainUpdated.prototype.setReferencedAssetsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 21, value);
};


/**
 * @param {!proto.zb.events.StateUpdate.AssetInfo=} opt_value
 * @param {number=} opt_index
 * @return {!proto.zb.events.StateUpdate.AssetInfo}
 */
proto.zb.events.BlockchainUpdated.prototype.addReferencedAssets = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 21, opt_value, proto.zb.events.StateUpdate.AssetInfo, opt_index);
};


proto.zb.events.BlockchainUpdated.prototype.clearReferencedAssetsList = function() {
  this.setReferencedAssetsList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.StateUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.zb.events.StateUpdate.repeatedFields_, null);
};
goog.inherits(proto.zb.events.StateUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.StateUpdate.displayName = 'proto.zb.events.StateUpdate';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.zb.events.StateUpdate.repeatedFields_ = [1,2,3,4,5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.StateUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.StateUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.StateUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    balancesList: jspb.Message.toObjectList(msg.getBalancesList(),
    proto.zb.events.StateUpdate.BalanceUpdate.toObject, includeInstance),
    leasingForAddressList: jspb.Message.toObjectList(msg.getLeasingForAddressList(),
    proto.zb.events.StateUpdate.LeasingUpdate.toObject, includeInstance),
    dataEntriesList: jspb.Message.toObjectList(msg.getDataEntriesList(),
    proto.zb.events.StateUpdate.DataEntryUpdate.toObject, includeInstance),
    assetsList: jspb.Message.toObjectList(msg.getAssetsList(),
    proto.zb.events.StateUpdate.AssetStateUpdate.toObject, includeInstance),
    individualLeasesList: jspb.Message.toObjectList(msg.getIndividualLeasesList(),
    proto.zb.events.StateUpdate.LeaseUpdate.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.StateUpdate}
 */
proto.zb.events.StateUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.StateUpdate;
  return proto.zb.events.StateUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.StateUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.StateUpdate}
 */
proto.zb.events.StateUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.zb.events.StateUpdate.BalanceUpdate;
      reader.readMessage(value,proto.zb.events.StateUpdate.BalanceUpdate.deserializeBinaryFromReader);
      msg.addBalances(value);
      break;
    case 2:
      var value = new proto.zb.events.StateUpdate.LeasingUpdate;
      reader.readMessage(value,proto.zb.events.StateUpdate.LeasingUpdate.deserializeBinaryFromReader);
      msg.addLeasingForAddress(value);
      break;
    case 3:
      var value = new proto.zb.events.StateUpdate.DataEntryUpdate;
      reader.readMessage(value,proto.zb.events.StateUpdate.DataEntryUpdate.deserializeBinaryFromReader);
      msg.addDataEntries(value);
      break;
    case 4:
      var value = new proto.zb.events.StateUpdate.AssetStateUpdate;
      reader.readMessage(value,proto.zb.events.StateUpdate.AssetStateUpdate.deserializeBinaryFromReader);
      msg.addAssets(value);
      break;
    case 5:
      var value = new proto.zb.events.StateUpdate.LeaseUpdate;
      reader.readMessage(value,proto.zb.events.StateUpdate.LeaseUpdate.deserializeBinaryFromReader);
      msg.addIndividualLeases(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.StateUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.StateUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBalancesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.zb.events.StateUpdate.BalanceUpdate.serializeBinaryToWriter
    );
  }
  f = message.getLeasingForAddressList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.zb.events.StateUpdate.LeasingUpdate.serializeBinaryToWriter
    );
  }
  f = message.getDataEntriesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.zb.events.StateUpdate.DataEntryUpdate.serializeBinaryToWriter
    );
  }
  f = message.getAssetsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      proto.zb.events.StateUpdate.AssetStateUpdate.serializeBinaryToWriter
    );
  }
  f = message.getIndividualLeasesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.zb.events.StateUpdate.LeaseUpdate.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.StateUpdate.BalanceUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.zb.events.StateUpdate.BalanceUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.StateUpdate.BalanceUpdate.displayName = 'proto.zb.events.StateUpdate.BalanceUpdate';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.StateUpdate.BalanceUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.StateUpdate.BalanceUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.StateUpdate.BalanceUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.BalanceUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress_asB64(),
    amountAfter: (f = msg.getAmountAfter()) && amount_pb.Amount.toObject(includeInstance, f),
    amountBefore: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.StateUpdate.BalanceUpdate}
 */
proto.zb.events.StateUpdate.BalanceUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.StateUpdate.BalanceUpdate;
  return proto.zb.events.StateUpdate.BalanceUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.StateUpdate.BalanceUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.StateUpdate.BalanceUpdate}
 */
proto.zb.events.StateUpdate.BalanceUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAddress(value);
      break;
    case 2:
      var value = new amount_pb.Amount;
      reader.readMessage(value,amount_pb.Amount.deserializeBinaryFromReader);
      msg.setAmountAfter(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmountBefore(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.BalanceUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.StateUpdate.BalanceUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.StateUpdate.BalanceUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.BalanceUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getAmountAfter();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      amount_pb.Amount.serializeBinaryToWriter
    );
  }
  f = message.getAmountBefore();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
};


/**
 * optional bytes address = 1;
 * @return {string}
 */
proto.zb.events.StateUpdate.BalanceUpdate.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes address = 1;
 * This is a type-conversion wrapper around `getAddress()`
 * @return {string}
 */
proto.zb.events.StateUpdate.BalanceUpdate.prototype.getAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAddress()));
};


/**
 * optional bytes address = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAddress()`
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.BalanceUpdate.prototype.getAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAddress()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.StateUpdate.BalanceUpdate.prototype.setAddress = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional zb.Amount amount_after = 2;
 * @return {?proto.zb.Amount}
 */
proto.zb.events.StateUpdate.BalanceUpdate.prototype.getAmountAfter = function() {
  return /** @type{?proto.zb.Amount} */ (
    jspb.Message.getWrapperField(this, amount_pb.Amount, 2));
};


/** @param {?proto.zb.Amount|undefined} value */
proto.zb.events.StateUpdate.BalanceUpdate.prototype.setAmountAfter = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.zb.events.StateUpdate.BalanceUpdate.prototype.clearAmountAfter = function() {
  this.setAmountAfter(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.StateUpdate.BalanceUpdate.prototype.hasAmountAfter = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional int64 amount_before = 3;
 * @return {number}
 */
proto.zb.events.StateUpdate.BalanceUpdate.prototype.getAmountBefore = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.zb.events.StateUpdate.BalanceUpdate.prototype.setAmountBefore = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.StateUpdate.LeasingUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.zb.events.StateUpdate.LeasingUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.StateUpdate.LeasingUpdate.displayName = 'proto.zb.events.StateUpdate.LeasingUpdate';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.StateUpdate.LeasingUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.StateUpdate.LeasingUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.LeasingUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress_asB64(),
    inAfter: jspb.Message.getFieldWithDefault(msg, 2, 0),
    outAfter: jspb.Message.getFieldWithDefault(msg, 3, 0),
    inBefore: jspb.Message.getFieldWithDefault(msg, 4, 0),
    outBefore: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.StateUpdate.LeasingUpdate}
 */
proto.zb.events.StateUpdate.LeasingUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.StateUpdate.LeasingUpdate;
  return proto.zb.events.StateUpdate.LeasingUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.StateUpdate.LeasingUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.StateUpdate.LeasingUpdate}
 */
proto.zb.events.StateUpdate.LeasingUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setInAfter(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setOutAfter(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setInBefore(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setOutBefore(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.StateUpdate.LeasingUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.StateUpdate.LeasingUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.LeasingUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getInAfter();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
  f = message.getOutAfter();
  if (f !== 0) {
    writer.writeInt64(
      3,
      f
    );
  }
  f = message.getInBefore();
  if (f !== 0) {
    writer.writeInt64(
      4,
      f
    );
  }
  f = message.getOutBefore();
  if (f !== 0) {
    writer.writeInt64(
      5,
      f
    );
  }
};


/**
 * optional bytes address = 1;
 * @return {string}
 */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes address = 1;
 * This is a type-conversion wrapper around `getAddress()`
 * @return {string}
 */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.getAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAddress()));
};


/**
 * optional bytes address = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAddress()`
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.getAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAddress()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.setAddress = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional int64 in_after = 2;
 * @return {number}
 */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.getInAfter = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.setInAfter = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional int64 out_after = 3;
 * @return {number}
 */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.getOutAfter = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.setOutAfter = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional int64 in_before = 4;
 * @return {number}
 */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.getInBefore = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.setInBefore = function(value) {
  jspb.Message.setProto3IntField(this, 4, value);
};


/**
 * optional int64 out_before = 5;
 * @return {number}
 */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.getOutBefore = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.zb.events.StateUpdate.LeasingUpdate.prototype.setOutBefore = function(value) {
  jspb.Message.setProto3IntField(this, 5, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.StateUpdate.LeaseUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.zb.events.StateUpdate.LeaseUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.StateUpdate.LeaseUpdate.displayName = 'proto.zb.events.StateUpdate.LeaseUpdate';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.StateUpdate.LeaseUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.StateUpdate.LeaseUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.LeaseUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    leaseId: msg.getLeaseId_asB64(),
    statusAfter: jspb.Message.getFieldWithDefault(msg, 2, 0),
    amount: jspb.Message.getFieldWithDefault(msg, 10, 0),
    sender: msg.getSender_asB64(),
    recipient: msg.getRecipient_asB64(),
    originTransactionId: msg.getOriginTransactionId_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.StateUpdate.LeaseUpdate}
 */
proto.zb.events.StateUpdate.LeaseUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.StateUpdate.LeaseUpdate;
  return proto.zb.events.StateUpdate.LeaseUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.StateUpdate.LeaseUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.StateUpdate.LeaseUpdate}
 */
proto.zb.events.StateUpdate.LeaseUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setLeaseId(value);
      break;
    case 2:
      var value = /** @type {!proto.zb.events.StateUpdate.LeaseUpdate.LeaseStatus} */ (reader.readEnum());
      msg.setStatusAfter(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setAmount(value);
      break;
    case 11:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSender(value);
      break;
    case 12:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRecipient(value);
      break;
    case 13:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setOriginTransactionId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.StateUpdate.LeaseUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.StateUpdate.LeaseUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.LeaseUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getLeaseId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getStatusAfter();
  if (f !== 0.0) {
    writer.writeEnum(
      2,
      f
    );
  }
  f = message.getAmount();
  if (f !== 0) {
    writer.writeInt64(
      10,
      f
    );
  }
  f = message.getSender_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      11,
      f
    );
  }
  f = message.getRecipient_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      12,
      f
    );
  }
  f = message.getOriginTransactionId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      13,
      f
    );
  }
};


/**
 * @enum {number}
 */
proto.zb.events.StateUpdate.LeaseUpdate.LeaseStatus = {
  INACTIVE: 0,
  ACTIVE: 1
};

/**
 * optional bytes lease_id = 1;
 * @return {string}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getLeaseId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes lease_id = 1;
 * This is a type-conversion wrapper around `getLeaseId()`
 * @return {string}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getLeaseId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getLeaseId()));
};


/**
 * optional bytes lease_id = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getLeaseId()`
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getLeaseId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getLeaseId()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.setLeaseId = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional LeaseStatus status_after = 2;
 * @return {!proto.zb.events.StateUpdate.LeaseUpdate.LeaseStatus}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getStatusAfter = function() {
  return /** @type {!proto.zb.events.StateUpdate.LeaseUpdate.LeaseStatus} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {!proto.zb.events.StateUpdate.LeaseUpdate.LeaseStatus} value */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.setStatusAfter = function(value) {
  jspb.Message.setProto3EnumField(this, 2, value);
};


/**
 * optional int64 amount = 10;
 * @return {number}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.setAmount = function(value) {
  jspb.Message.setProto3IntField(this, 10, value);
};


/**
 * optional bytes sender = 11;
 * @return {string}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getSender = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 11, ""));
};


/**
 * optional bytes sender = 11;
 * This is a type-conversion wrapper around `getSender()`
 * @return {string}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getSender_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSender()));
};


/**
 * optional bytes sender = 11;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSender()`
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getSender_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSender()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.setSender = function(value) {
  jspb.Message.setProto3BytesField(this, 11, value);
};


/**
 * optional bytes recipient = 12;
 * @return {string}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getRecipient = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 12, ""));
};


/**
 * optional bytes recipient = 12;
 * This is a type-conversion wrapper around `getRecipient()`
 * @return {string}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getRecipient_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRecipient()));
};


/**
 * optional bytes recipient = 12;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRecipient()`
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getRecipient_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRecipient()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.setRecipient = function(value) {
  jspb.Message.setProto3BytesField(this, 12, value);
};


/**
 * optional bytes origin_transaction_id = 13;
 * @return {string}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getOriginTransactionId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 13, ""));
};


/**
 * optional bytes origin_transaction_id = 13;
 * This is a type-conversion wrapper around `getOriginTransactionId()`
 * @return {string}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getOriginTransactionId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getOriginTransactionId()));
};


/**
 * optional bytes origin_transaction_id = 13;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getOriginTransactionId()`
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.getOriginTransactionId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getOriginTransactionId()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.StateUpdate.LeaseUpdate.prototype.setOriginTransactionId = function(value) {
  jspb.Message.setProto3BytesField(this, 13, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.StateUpdate.DataEntryUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.zb.events.StateUpdate.DataEntryUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.StateUpdate.DataEntryUpdate.displayName = 'proto.zb.events.StateUpdate.DataEntryUpdate';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.StateUpdate.DataEntryUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.StateUpdate.DataEntryUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.StateUpdate.DataEntryUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.DataEntryUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress_asB64(),
    dataEntry: (f = msg.getDataEntry()) && transaction_pb.DataTransactionData.DataEntry.toObject(includeInstance, f),
    dataEntryBefore: (f = msg.getDataEntryBefore()) && transaction_pb.DataTransactionData.DataEntry.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.StateUpdate.DataEntryUpdate}
 */
proto.zb.events.StateUpdate.DataEntryUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.StateUpdate.DataEntryUpdate;
  return proto.zb.events.StateUpdate.DataEntryUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.StateUpdate.DataEntryUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.StateUpdate.DataEntryUpdate}
 */
proto.zb.events.StateUpdate.DataEntryUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAddress(value);
      break;
    case 2:
      var value = new transaction_pb.DataTransactionData.DataEntry;
      reader.readMessage(value,transaction_pb.DataTransactionData.DataEntry.deserializeBinaryFromReader);
      msg.setDataEntry(value);
      break;
    case 10:
      var value = new transaction_pb.DataTransactionData.DataEntry;
      reader.readMessage(value,transaction_pb.DataTransactionData.DataEntry.deserializeBinaryFromReader);
      msg.setDataEntryBefore(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.DataEntryUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.StateUpdate.DataEntryUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.StateUpdate.DataEntryUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.DataEntryUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddress_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getDataEntry();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      transaction_pb.DataTransactionData.DataEntry.serializeBinaryToWriter
    );
  }
  f = message.getDataEntryBefore();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      transaction_pb.DataTransactionData.DataEntry.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes address = 1;
 * @return {string}
 */
proto.zb.events.StateUpdate.DataEntryUpdate.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes address = 1;
 * This is a type-conversion wrapper around `getAddress()`
 * @return {string}
 */
proto.zb.events.StateUpdate.DataEntryUpdate.prototype.getAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAddress()));
};


/**
 * optional bytes address = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAddress()`
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.DataEntryUpdate.prototype.getAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAddress()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.StateUpdate.DataEntryUpdate.prototype.setAddress = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional zb.DataTransactionData.DataEntry data_entry = 2;
 * @return {?proto.zb.DataTransactionData.DataEntry}
 */
proto.zb.events.StateUpdate.DataEntryUpdate.prototype.getDataEntry = function() {
  return /** @type{?proto.zb.DataTransactionData.DataEntry} */ (
    jspb.Message.getWrapperField(this, transaction_pb.DataTransactionData.DataEntry, 2));
};


/** @param {?proto.zb.DataTransactionData.DataEntry|undefined} value */
proto.zb.events.StateUpdate.DataEntryUpdate.prototype.setDataEntry = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.zb.events.StateUpdate.DataEntryUpdate.prototype.clearDataEntry = function() {
  this.setDataEntry(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.StateUpdate.DataEntryUpdate.prototype.hasDataEntry = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional zb.DataTransactionData.DataEntry data_entry_before = 10;
 * @return {?proto.zb.DataTransactionData.DataEntry}
 */
proto.zb.events.StateUpdate.DataEntryUpdate.prototype.getDataEntryBefore = function() {
  return /** @type{?proto.zb.DataTransactionData.DataEntry} */ (
    jspb.Message.getWrapperField(this, transaction_pb.DataTransactionData.DataEntry, 10));
};


/** @param {?proto.zb.DataTransactionData.DataEntry|undefined} value */
proto.zb.events.StateUpdate.DataEntryUpdate.prototype.setDataEntryBefore = function(value) {
  jspb.Message.setWrapperField(this, 10, value);
};


proto.zb.events.StateUpdate.DataEntryUpdate.prototype.clearDataEntryBefore = function() {
  this.setDataEntryBefore(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.StateUpdate.DataEntryUpdate.prototype.hasDataEntryBefore = function() {
  return jspb.Message.getField(this, 10) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.StateUpdate.AssetStateUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.zb.events.StateUpdate.AssetStateUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.StateUpdate.AssetStateUpdate.displayName = 'proto.zb.events.StateUpdate.AssetStateUpdate';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.StateUpdate.AssetStateUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.StateUpdate.AssetStateUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.StateUpdate.AssetStateUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.AssetStateUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    before: (f = msg.getBefore()) && proto.zb.events.StateUpdate.AssetDetails.toObject(includeInstance, f),
    after: (f = msg.getAfter()) && proto.zb.events.StateUpdate.AssetDetails.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.StateUpdate.AssetStateUpdate}
 */
proto.zb.events.StateUpdate.AssetStateUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.StateUpdate.AssetStateUpdate;
  return proto.zb.events.StateUpdate.AssetStateUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.StateUpdate.AssetStateUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.StateUpdate.AssetStateUpdate}
 */
proto.zb.events.StateUpdate.AssetStateUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.zb.events.StateUpdate.AssetDetails;
      reader.readMessage(value,proto.zb.events.StateUpdate.AssetDetails.deserializeBinaryFromReader);
      msg.setBefore(value);
      break;
    case 2:
      var value = new proto.zb.events.StateUpdate.AssetDetails;
      reader.readMessage(value,proto.zb.events.StateUpdate.AssetDetails.deserializeBinaryFromReader);
      msg.setAfter(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.AssetStateUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.StateUpdate.AssetStateUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.StateUpdate.AssetStateUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.AssetStateUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getBefore();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.zb.events.StateUpdate.AssetDetails.serializeBinaryToWriter
    );
  }
  f = message.getAfter();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.zb.events.StateUpdate.AssetDetails.serializeBinaryToWriter
    );
  }
};


/**
 * optional AssetDetails before = 1;
 * @return {?proto.zb.events.StateUpdate.AssetDetails}
 */
proto.zb.events.StateUpdate.AssetStateUpdate.prototype.getBefore = function() {
  return /** @type{?proto.zb.events.StateUpdate.AssetDetails} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.StateUpdate.AssetDetails, 1));
};


/** @param {?proto.zb.events.StateUpdate.AssetDetails|undefined} value */
proto.zb.events.StateUpdate.AssetStateUpdate.prototype.setBefore = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.zb.events.StateUpdate.AssetStateUpdate.prototype.clearBefore = function() {
  this.setBefore(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.StateUpdate.AssetStateUpdate.prototype.hasBefore = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional AssetDetails after = 2;
 * @return {?proto.zb.events.StateUpdate.AssetDetails}
 */
proto.zb.events.StateUpdate.AssetStateUpdate.prototype.getAfter = function() {
  return /** @type{?proto.zb.events.StateUpdate.AssetDetails} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.StateUpdate.AssetDetails, 2));
};


/** @param {?proto.zb.events.StateUpdate.AssetDetails|undefined} value */
proto.zb.events.StateUpdate.AssetStateUpdate.prototype.setAfter = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.zb.events.StateUpdate.AssetStateUpdate.prototype.clearAfter = function() {
  this.setAfter(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.StateUpdate.AssetStateUpdate.prototype.hasAfter = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.StateUpdate.AssetDetails = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.zb.events.StateUpdate.AssetDetails, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.StateUpdate.AssetDetails.displayName = 'proto.zb.events.StateUpdate.AssetDetails';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.StateUpdate.AssetDetails.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.StateUpdate.AssetDetails} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.AssetDetails.toObject = function(includeInstance, msg) {
  var f, obj = {
    assetId: msg.getAssetId_asB64(),
    issuer: msg.getIssuer_asB64(),
    decimals: jspb.Message.getFieldWithDefault(msg, 3, 0),
    name: jspb.Message.getFieldWithDefault(msg, 4, ""),
    description: jspb.Message.getFieldWithDefault(msg, 5, ""),
    reissuable: jspb.Message.getFieldWithDefault(msg, 6, false),
    volume: jspb.Message.getFieldWithDefault(msg, 7, 0),
    scriptInfo: (f = msg.getScriptInfo()) && proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.toObject(includeInstance, f),
    sponsorship: jspb.Message.getFieldWithDefault(msg, 9, 0),
    nft: jspb.Message.getFieldWithDefault(msg, 10, false),
    lastUpdated: jspb.Message.getFieldWithDefault(msg, 11, 0),
    safeVolume: msg.getSafeVolume_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.StateUpdate.AssetDetails}
 */
proto.zb.events.StateUpdate.AssetDetails.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.StateUpdate.AssetDetails;
  return proto.zb.events.StateUpdate.AssetDetails.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.StateUpdate.AssetDetails} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.StateUpdate.AssetDetails}
 */
proto.zb.events.StateUpdate.AssetDetails.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAssetId(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setIssuer(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setDecimals(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setDescription(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setReissuable(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setVolume(value);
      break;
    case 8:
      var value = new proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo;
      reader.readMessage(value,proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.deserializeBinaryFromReader);
      msg.setScriptInfo(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setSponsorship(value);
      break;
    case 10:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setNft(value);
      break;
    case 11:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setLastUpdated(value);
      break;
    case 20:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSafeVolume(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.StateUpdate.AssetDetails.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.StateUpdate.AssetDetails} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.AssetDetails.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAssetId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getIssuer_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getDecimals();
  if (f !== 0) {
    writer.writeInt32(
      3,
      f
    );
  }
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getDescription();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
  f = message.getReissuable();
  if (f) {
    writer.writeBool(
      6,
      f
    );
  }
  f = message.getVolume();
  if (f !== 0) {
    writer.writeInt64(
      7,
      f
    );
  }
  f = message.getScriptInfo();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.serializeBinaryToWriter
    );
  }
  f = message.getSponsorship();
  if (f !== 0) {
    writer.writeInt64(
      9,
      f
    );
  }
  f = message.getNft();
  if (f) {
    writer.writeBool(
      10,
      f
    );
  }
  f = message.getLastUpdated();
  if (f !== 0) {
    writer.writeInt32(
      11,
      f
    );
  }
  f = message.getSafeVolume_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      20,
      f
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.displayName = 'proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    script: msg.getScript_asB64(),
    complexity: jspb.Message.getFieldWithDefault(msg, 2, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo}
 */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo;
  return proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo}
 */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setScript(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setComplexity(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getScript_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getComplexity();
  if (f !== 0) {
    writer.writeInt64(
      2,
      f
    );
  }
};


/**
 * optional bytes script = 1;
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.prototype.getScript = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes script = 1;
 * This is a type-conversion wrapper around `getScript()`
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.prototype.getScript_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getScript()));
};


/**
 * optional bytes script = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getScript()`
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.prototype.getScript_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getScript()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.prototype.setScript = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional int64 complexity = 2;
 * @return {number}
 */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.prototype.getComplexity = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo.prototype.setComplexity = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional bytes asset_id = 1;
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getAssetId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes asset_id = 1;
 * This is a type-conversion wrapper around `getAssetId()`
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getAssetId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAssetId()));
};


/**
 * optional bytes asset_id = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAssetId()`
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getAssetId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAssetId()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.StateUpdate.AssetDetails.prototype.setAssetId = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bytes issuer = 2;
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getIssuer = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes issuer = 2;
 * This is a type-conversion wrapper around `getIssuer()`
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getIssuer_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getIssuer()));
};


/**
 * optional bytes issuer = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getIssuer()`
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getIssuer_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getIssuer()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.StateUpdate.AssetDetails.prototype.setIssuer = function(value) {
  jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional int32 decimals = 3;
 * @return {number}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getDecimals = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.zb.events.StateUpdate.AssetDetails.prototype.setDecimals = function(value) {
  jspb.Message.setProto3IntField(this, 3, value);
};


/**
 * optional string name = 4;
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.zb.events.StateUpdate.AssetDetails.prototype.setName = function(value) {
  jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional string description = 5;
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getDescription = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.zb.events.StateUpdate.AssetDetails.prototype.setDescription = function(value) {
  jspb.Message.setProto3StringField(this, 5, value);
};


/**
 * optional bool reissuable = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getReissuable = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.zb.events.StateUpdate.AssetDetails.prototype.setReissuable = function(value) {
  jspb.Message.setProto3BooleanField(this, 6, value);
};


/**
 * optional int64 volume = 7;
 * @return {number}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getVolume = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.zb.events.StateUpdate.AssetDetails.prototype.setVolume = function(value) {
  jspb.Message.setProto3IntField(this, 7, value);
};


/**
 * optional AssetScriptInfo script_info = 8;
 * @return {?proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getScriptInfo = function() {
  return /** @type{?proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo, 8));
};


/** @param {?proto.zb.events.StateUpdate.AssetDetails.AssetScriptInfo|undefined} value */
proto.zb.events.StateUpdate.AssetDetails.prototype.setScriptInfo = function(value) {
  jspb.Message.setWrapperField(this, 8, value);
};


proto.zb.events.StateUpdate.AssetDetails.prototype.clearScriptInfo = function() {
  this.setScriptInfo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.hasScriptInfo = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional int64 sponsorship = 9;
 * @return {number}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getSponsorship = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.zb.events.StateUpdate.AssetDetails.prototype.setSponsorship = function(value) {
  jspb.Message.setProto3IntField(this, 9, value);
};


/**
 * optional bool nft = 10;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getNft = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 10, false));
};


/** @param {boolean} value */
proto.zb.events.StateUpdate.AssetDetails.prototype.setNft = function(value) {
  jspb.Message.setProto3BooleanField(this, 10, value);
};


/**
 * optional int32 last_updated = 11;
 * @return {number}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getLastUpdated = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 11, 0));
};


/** @param {number} value */
proto.zb.events.StateUpdate.AssetDetails.prototype.setLastUpdated = function(value) {
  jspb.Message.setProto3IntField(this, 11, value);
};


/**
 * optional bytes safe_volume = 20;
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getSafeVolume = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 20, ""));
};


/**
 * optional bytes safe_volume = 20;
 * This is a type-conversion wrapper around `getSafeVolume()`
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getSafeVolume_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSafeVolume()));
};


/**
 * optional bytes safe_volume = 20;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSafeVolume()`
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.AssetDetails.prototype.getSafeVolume_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSafeVolume()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.StateUpdate.AssetDetails.prototype.setSafeVolume = function(value) {
  jspb.Message.setProto3BytesField(this, 20, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.StateUpdate.AssetInfo = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.zb.events.StateUpdate.AssetInfo, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.StateUpdate.AssetInfo.displayName = 'proto.zb.events.StateUpdate.AssetInfo';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.StateUpdate.AssetInfo.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.StateUpdate.AssetInfo.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.StateUpdate.AssetInfo} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.AssetInfo.toObject = function(includeInstance, msg) {
  var f, obj = {
    id: msg.getId_asB64(),
    decimals: jspb.Message.getFieldWithDefault(msg, 2, 0),
    name: jspb.Message.getFieldWithDefault(msg, 3, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.StateUpdate.AssetInfo}
 */
proto.zb.events.StateUpdate.AssetInfo.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.StateUpdate.AssetInfo;
  return proto.zb.events.StateUpdate.AssetInfo.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.StateUpdate.AssetInfo} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.StateUpdate.AssetInfo}
 */
proto.zb.events.StateUpdate.AssetInfo.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setId(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readInt32());
      msg.setDecimals(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.AssetInfo.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.StateUpdate.AssetInfo.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.StateUpdate.AssetInfo} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.StateUpdate.AssetInfo.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getDecimals();
  if (f !== 0) {
    writer.writeInt32(
      2,
      f
    );
  }
  f = message.getName();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional bytes id = 1;
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetInfo.prototype.getId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes id = 1;
 * This is a type-conversion wrapper around `getId()`
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetInfo.prototype.getId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getId()));
};


/**
 * optional bytes id = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getId()`
 * @return {!Uint8Array}
 */
proto.zb.events.StateUpdate.AssetInfo.prototype.getId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getId()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.StateUpdate.AssetInfo.prototype.setId = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional int32 decimals = 2;
 * @return {number}
 */
proto.zb.events.StateUpdate.AssetInfo.prototype.getDecimals = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.zb.events.StateUpdate.AssetInfo.prototype.setDecimals = function(value) {
  jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string name = 3;
 * @return {string}
 */
proto.zb.events.StateUpdate.AssetInfo.prototype.getName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.zb.events.StateUpdate.AssetInfo.prototype.setName = function(value) {
  jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * repeated BalanceUpdate balances = 1;
 * @return {!Array<!proto.zb.events.StateUpdate.BalanceUpdate>}
 */
proto.zb.events.StateUpdate.prototype.getBalancesList = function() {
  return /** @type{!Array<!proto.zb.events.StateUpdate.BalanceUpdate>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.zb.events.StateUpdate.BalanceUpdate, 1));
};


/** @param {!Array<!proto.zb.events.StateUpdate.BalanceUpdate>} value */
proto.zb.events.StateUpdate.prototype.setBalancesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.zb.events.StateUpdate.BalanceUpdate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.zb.events.StateUpdate.BalanceUpdate}
 */
proto.zb.events.StateUpdate.prototype.addBalances = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.zb.events.StateUpdate.BalanceUpdate, opt_index);
};


proto.zb.events.StateUpdate.prototype.clearBalancesList = function() {
  this.setBalancesList([]);
};


/**
 * repeated LeasingUpdate leasing_for_address = 2;
 * @return {!Array<!proto.zb.events.StateUpdate.LeasingUpdate>}
 */
proto.zb.events.StateUpdate.prototype.getLeasingForAddressList = function() {
  return /** @type{!Array<!proto.zb.events.StateUpdate.LeasingUpdate>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.zb.events.StateUpdate.LeasingUpdate, 2));
};


/** @param {!Array<!proto.zb.events.StateUpdate.LeasingUpdate>} value */
proto.zb.events.StateUpdate.prototype.setLeasingForAddressList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.zb.events.StateUpdate.LeasingUpdate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.zb.events.StateUpdate.LeasingUpdate}
 */
proto.zb.events.StateUpdate.prototype.addLeasingForAddress = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.zb.events.StateUpdate.LeasingUpdate, opt_index);
};


proto.zb.events.StateUpdate.prototype.clearLeasingForAddressList = function() {
  this.setLeasingForAddressList([]);
};


/**
 * repeated DataEntryUpdate data_entries = 3;
 * @return {!Array<!proto.zb.events.StateUpdate.DataEntryUpdate>}
 */
proto.zb.events.StateUpdate.prototype.getDataEntriesList = function() {
  return /** @type{!Array<!proto.zb.events.StateUpdate.DataEntryUpdate>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.zb.events.StateUpdate.DataEntryUpdate, 3));
};


/** @param {!Array<!proto.zb.events.StateUpdate.DataEntryUpdate>} value */
proto.zb.events.StateUpdate.prototype.setDataEntriesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.zb.events.StateUpdate.DataEntryUpdate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.zb.events.StateUpdate.DataEntryUpdate}
 */
proto.zb.events.StateUpdate.prototype.addDataEntries = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.zb.events.StateUpdate.DataEntryUpdate, opt_index);
};


proto.zb.events.StateUpdate.prototype.clearDataEntriesList = function() {
  this.setDataEntriesList([]);
};


/**
 * repeated AssetStateUpdate assets = 4;
 * @return {!Array<!proto.zb.events.StateUpdate.AssetStateUpdate>}
 */
proto.zb.events.StateUpdate.prototype.getAssetsList = function() {
  return /** @type{!Array<!proto.zb.events.StateUpdate.AssetStateUpdate>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.zb.events.StateUpdate.AssetStateUpdate, 4));
};


/** @param {!Array<!proto.zb.events.StateUpdate.AssetStateUpdate>} value */
proto.zb.events.StateUpdate.prototype.setAssetsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.zb.events.StateUpdate.AssetStateUpdate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.zb.events.StateUpdate.AssetStateUpdate}
 */
proto.zb.events.StateUpdate.prototype.addAssets = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.zb.events.StateUpdate.AssetStateUpdate, opt_index);
};


proto.zb.events.StateUpdate.prototype.clearAssetsList = function() {
  this.setAssetsList([]);
};


/**
 * repeated LeaseUpdate individual_leases = 5;
 * @return {!Array<!proto.zb.events.StateUpdate.LeaseUpdate>}
 */
proto.zb.events.StateUpdate.prototype.getIndividualLeasesList = function() {
  return /** @type{!Array<!proto.zb.events.StateUpdate.LeaseUpdate>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.zb.events.StateUpdate.LeaseUpdate, 5));
};


/** @param {!Array<!proto.zb.events.StateUpdate.LeaseUpdate>} value */
proto.zb.events.StateUpdate.prototype.setIndividualLeasesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.zb.events.StateUpdate.LeaseUpdate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.zb.events.StateUpdate.LeaseUpdate}
 */
proto.zb.events.StateUpdate.prototype.addIndividualLeases = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.zb.events.StateUpdate.LeaseUpdate, opt_index);
};


proto.zb.events.StateUpdate.prototype.clearIndividualLeasesList = function() {
  this.setIndividualLeasesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.TransactionMetadata = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.zb.events.TransactionMetadata.oneofGroups_);
};
goog.inherits(proto.zb.events.TransactionMetadata, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.TransactionMetadata.displayName = 'proto.zb.events.TransactionMetadata';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.zb.events.TransactionMetadata.oneofGroups_ = [[104,111,116,117]];

/**
 * @enum {number}
 */
proto.zb.events.TransactionMetadata.MetadataCase = {
  METADATA_NOT_SET: 0,
  TRANSFER: 104,
  MASS_TRANSFER: 111,
  INVOKE_SCRIPT: 116,
  LEASE_META: 117
};

/**
 * @return {proto.zb.events.TransactionMetadata.MetadataCase}
 */
proto.zb.events.TransactionMetadata.prototype.getMetadataCase = function() {
  return /** @type {proto.zb.events.TransactionMetadata.MetadataCase} */(jspb.Message.computeOneofCase(this, proto.zb.events.TransactionMetadata.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.TransactionMetadata.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.TransactionMetadata.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.TransactionMetadata} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.toObject = function(includeInstance, msg) {
  var f, obj = {
    transfer: (f = msg.getTransfer()) && proto.zb.events.TransactionMetadata.TransferMetadata.toObject(includeInstance, f),
    massTransfer: (f = msg.getMassTransfer()) && proto.zb.events.TransactionMetadata.MassTransferMetadata.toObject(includeInstance, f),
    invokeScript: (f = msg.getInvokeScript()) && proto.zb.events.TransactionMetadata.InvokeScriptMetadata.toObject(includeInstance, f),
    leaseMeta: (f = msg.getLeaseMeta()) && proto.zb.events.TransactionMetadata.LeaseMetadata.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.TransactionMetadata}
 */
proto.zb.events.TransactionMetadata.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.TransactionMetadata;
  return proto.zb.events.TransactionMetadata.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.TransactionMetadata} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.TransactionMetadata}
 */
proto.zb.events.TransactionMetadata.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 104:
      var value = new proto.zb.events.TransactionMetadata.TransferMetadata;
      reader.readMessage(value,proto.zb.events.TransactionMetadata.TransferMetadata.deserializeBinaryFromReader);
      msg.setTransfer(value);
      break;
    case 111:
      var value = new proto.zb.events.TransactionMetadata.MassTransferMetadata;
      reader.readMessage(value,proto.zb.events.TransactionMetadata.MassTransferMetadata.deserializeBinaryFromReader);
      msg.setMassTransfer(value);
      break;
    case 116:
      var value = new proto.zb.events.TransactionMetadata.InvokeScriptMetadata;
      reader.readMessage(value,proto.zb.events.TransactionMetadata.InvokeScriptMetadata.deserializeBinaryFromReader);
      msg.setInvokeScript(value);
      break;
    case 117:
      var value = new proto.zb.events.TransactionMetadata.LeaseMetadata;
      reader.readMessage(value,proto.zb.events.TransactionMetadata.LeaseMetadata.deserializeBinaryFromReader);
      msg.setLeaseMeta(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.TransactionMetadata.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.TransactionMetadata.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.TransactionMetadata} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTransfer();
  if (f != null) {
    writer.writeMessage(
      104,
      f,
      proto.zb.events.TransactionMetadata.TransferMetadata.serializeBinaryToWriter
    );
  }
  f = message.getMassTransfer();
  if (f != null) {
    writer.writeMessage(
      111,
      f,
      proto.zb.events.TransactionMetadata.MassTransferMetadata.serializeBinaryToWriter
    );
  }
  f = message.getInvokeScript();
  if (f != null) {
    writer.writeMessage(
      116,
      f,
      proto.zb.events.TransactionMetadata.InvokeScriptMetadata.serializeBinaryToWriter
    );
  }
  f = message.getLeaseMeta();
  if (f != null) {
    writer.writeMessage(
      117,
      f,
      proto.zb.events.TransactionMetadata.LeaseMetadata.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.TransactionMetadata.TransferMetadata = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.zb.events.TransactionMetadata.TransferMetadata, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.TransactionMetadata.TransferMetadata.displayName = 'proto.zb.events.TransactionMetadata.TransferMetadata';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.TransactionMetadata.TransferMetadata.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.TransactionMetadata.TransferMetadata.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.TransactionMetadata.TransferMetadata} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.TransferMetadata.toObject = function(includeInstance, msg) {
  var f, obj = {
    recipientAddress: msg.getRecipientAddress_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.TransactionMetadata.TransferMetadata}
 */
proto.zb.events.TransactionMetadata.TransferMetadata.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.TransactionMetadata.TransferMetadata;
  return proto.zb.events.TransactionMetadata.TransferMetadata.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.TransactionMetadata.TransferMetadata} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.TransactionMetadata.TransferMetadata}
 */
proto.zb.events.TransactionMetadata.TransferMetadata.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRecipientAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.TransactionMetadata.TransferMetadata.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.TransactionMetadata.TransferMetadata.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.TransactionMetadata.TransferMetadata} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.TransferMetadata.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRecipientAddress_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes recipient_address = 1;
 * @return {string}
 */
proto.zb.events.TransactionMetadata.TransferMetadata.prototype.getRecipientAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes recipient_address = 1;
 * This is a type-conversion wrapper around `getRecipientAddress()`
 * @return {string}
 */
proto.zb.events.TransactionMetadata.TransferMetadata.prototype.getRecipientAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRecipientAddress()));
};


/**
 * optional bytes recipient_address = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRecipientAddress()`
 * @return {!Uint8Array}
 */
proto.zb.events.TransactionMetadata.TransferMetadata.prototype.getRecipientAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRecipientAddress()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.TransactionMetadata.TransferMetadata.prototype.setRecipientAddress = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.TransactionMetadata.MassTransferMetadata = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.zb.events.TransactionMetadata.MassTransferMetadata.repeatedFields_, null);
};
goog.inherits(proto.zb.events.TransactionMetadata.MassTransferMetadata, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.TransactionMetadata.MassTransferMetadata.displayName = 'proto.zb.events.TransactionMetadata.MassTransferMetadata';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.zb.events.TransactionMetadata.MassTransferMetadata.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.TransactionMetadata.MassTransferMetadata.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.TransactionMetadata.MassTransferMetadata.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.TransactionMetadata.MassTransferMetadata} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.MassTransferMetadata.toObject = function(includeInstance, msg) {
  var f, obj = {
    recipientsAddressesList: msg.getRecipientsAddressesList_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.TransactionMetadata.MassTransferMetadata}
 */
proto.zb.events.TransactionMetadata.MassTransferMetadata.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.TransactionMetadata.MassTransferMetadata;
  return proto.zb.events.TransactionMetadata.MassTransferMetadata.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.TransactionMetadata.MassTransferMetadata} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.TransactionMetadata.MassTransferMetadata}
 */
proto.zb.events.TransactionMetadata.MassTransferMetadata.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addRecipientsAddresses(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.TransactionMetadata.MassTransferMetadata.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.TransactionMetadata.MassTransferMetadata.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.TransactionMetadata.MassTransferMetadata} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.MassTransferMetadata.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRecipientsAddressesList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      1,
      f
    );
  }
};


/**
 * repeated bytes recipients_addresses = 1;
 * @return {!Array<string>}
 */
proto.zb.events.TransactionMetadata.MassTransferMetadata.prototype.getRecipientsAddressesList = function() {
  return /** @type {!Array<string>} */ (jspb.Message.getRepeatedField(this, 1));
};


/**
 * repeated bytes recipients_addresses = 1;
 * This is a type-conversion wrapper around `getRecipientsAddressesList()`
 * @return {!Array<string>}
 */
proto.zb.events.TransactionMetadata.MassTransferMetadata.prototype.getRecipientsAddressesList_asB64 = function() {
  return /** @type {!Array<string>} */ (jspb.Message.bytesListAsB64(
      this.getRecipientsAddressesList()));
};


/**
 * repeated bytes recipients_addresses = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRecipientsAddressesList()`
 * @return {!Array<!Uint8Array>}
 */
proto.zb.events.TransactionMetadata.MassTransferMetadata.prototype.getRecipientsAddressesList_asU8 = function() {
  return /** @type {!Array<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getRecipientsAddressesList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.zb.events.TransactionMetadata.MassTransferMetadata.prototype.setRecipientsAddressesList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.zb.events.TransactionMetadata.MassTransferMetadata.prototype.addRecipientsAddresses = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.zb.events.TransactionMetadata.MassTransferMetadata.prototype.clearRecipientsAddressesList = function() {
  this.setRecipientsAddressesList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.repeatedFields_, null);
};
goog.inherits(proto.zb.events.TransactionMetadata.InvokeScriptMetadata, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.TransactionMetadata.InvokeScriptMetadata.displayName = 'proto.zb.events.TransactionMetadata.InvokeScriptMetadata';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.repeatedFields_ = [3,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.TransactionMetadata.InvokeScriptMetadata.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.toObject = function(includeInstance, msg) {
  var f, obj = {
    dAppAddress: msg.getDAppAddress_asB64(),
    functionName: jspb.Message.getFieldWithDefault(msg, 2, ""),
    argumentsList: jspb.Message.toObjectList(msg.getArgumentsList(),
    proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.toObject, includeInstance),
    paymentsList: jspb.Message.toObjectList(msg.getPaymentsList(),
    amount_pb.Amount.toObject, includeInstance),
    result: (f = msg.getResult()) && invoke_script_result_pb.InvokeScriptResult.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.TransactionMetadata.InvokeScriptMetadata;
  return proto.zb.events.TransactionMetadata.InvokeScriptMetadata.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setDAppAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setFunctionName(value);
      break;
    case 3:
      var value = new proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument;
      reader.readMessage(value,proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.deserializeBinaryFromReader);
      msg.addArguments(value);
      break;
    case 4:
      var value = new amount_pb.Amount;
      reader.readMessage(value,amount_pb.Amount.deserializeBinaryFromReader);
      msg.addPayments(value);
      break;
    case 5:
      var value = new invoke_script_result_pb.InvokeScriptResult;
      reader.readMessage(value,invoke_script_result_pb.InvokeScriptResult.deserializeBinaryFromReader);
      msg.setResult(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.TransactionMetadata.InvokeScriptMetadata.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDAppAddress_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getFunctionName();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getArgumentsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.serializeBinaryToWriter
    );
  }
  f = message.getPaymentsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      amount_pb.Amount.serializeBinaryToWriter
    );
  }
  f = message.getResult();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      invoke_script_result_pb.InvokeScriptResult.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.oneofGroups_);
};
goog.inherits(proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.displayName = 'proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument';
}
/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.oneofGroups_ = [[1,2,3,4,10]];

/**
 * @enum {number}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.ValueCase = {
  VALUE_NOT_SET: 0,
  INTEGER_VALUE: 1,
  BINARY_VALUE: 2,
  STRING_VALUE: 3,
  BOOLEAN_VALUE: 4,
  LIST: 10
};

/**
 * @return {proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.ValueCase}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.getValueCase = function() {
  return /** @type {proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.ValueCase} */(jspb.Message.computeOneofCase(this, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.toObject = function(includeInstance, msg) {
  var f, obj = {
    integerValue: jspb.Message.getFieldWithDefault(msg, 1, 0),
    binaryValue: msg.getBinaryValue_asB64(),
    stringValue: jspb.Message.getFieldWithDefault(msg, 3, ""),
    booleanValue: jspb.Message.getFieldWithDefault(msg, 4, false),
    list: (f = msg.getList()) && proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument;
  return proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readInt64());
      msg.setIntegerValue(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBinaryValue(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setStringValue(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setBooleanValue(value);
      break;
    case 10:
      var value = new proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List;
      reader.readMessage(value,proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.deserializeBinaryFromReader);
      msg.setList(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeInt64(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBool(
      4,
      f
    );
  }
  f = message.getList();
  if (f != null) {
    writer.writeMessage(
      10,
      f,
      proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.serializeBinaryToWriter
    );
  }
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.repeatedFields_, null);
};
goog.inherits(proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.displayName = 'proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.toObject = function(includeInstance, msg) {
  var f, obj = {
    itemsList: jspb.Message.toObjectList(msg.getItemsList(),
    proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List;
  return proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument;
      reader.readMessage(value,proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.deserializeBinaryFromReader);
      msg.addItems(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getItemsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.serializeBinaryToWriter
    );
  }
};


/**
 * repeated Argument items = 1;
 * @return {!Array<!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument>}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.prototype.getItemsList = function() {
  return /** @type{!Array<!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument, 1));
};


/** @param {!Array<!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument>} value */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.prototype.setItemsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument=} opt_value
 * @param {number=} opt_index
 * @return {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.prototype.addItems = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument, opt_index);
};


proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List.prototype.clearItemsList = function() {
  this.setItemsList([]);
};


/**
 * optional int64 integer_value = 1;
 * @return {number}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.getIntegerValue = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.setIntegerValue = function(value) {
  jspb.Message.setOneofField(this, 1, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.oneofGroups_[0], value);
};


proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.clearIntegerValue = function() {
  jspb.Message.setOneofField(this, 1, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.hasIntegerValue = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes binary_value = 2;
 * @return {string}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.getBinaryValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes binary_value = 2;
 * This is a type-conversion wrapper around `getBinaryValue()`
 * @return {string}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.getBinaryValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBinaryValue()));
};


/**
 * optional bytes binary_value = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBinaryValue()`
 * @return {!Uint8Array}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.getBinaryValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBinaryValue()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.setBinaryValue = function(value) {
  jspb.Message.setOneofField(this, 2, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.oneofGroups_[0], value);
};


proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.clearBinaryValue = function() {
  jspb.Message.setOneofField(this, 2, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.hasBinaryValue = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string string_value = 3;
 * @return {string}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.getStringValue = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.setStringValue = function(value) {
  jspb.Message.setOneofField(this, 3, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.oneofGroups_[0], value);
};


proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.clearStringValue = function() {
  jspb.Message.setOneofField(this, 3, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.hasStringValue = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bool boolean_value = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.getBooleanValue = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.setBooleanValue = function(value) {
  jspb.Message.setOneofField(this, 4, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.oneofGroups_[0], value);
};


proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.clearBooleanValue = function() {
  jspb.Message.setOneofField(this, 4, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.oneofGroups_[0], undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.hasBooleanValue = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional List list = 10;
 * @return {?proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.getList = function() {
  return /** @type{?proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List, 10));
};


/** @param {?proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.List|undefined} value */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.setList = function(value) {
  jspb.Message.setOneofWrapperField(this, 10, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.oneofGroups_[0], value);
};


proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.clearList = function() {
  this.setList(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument.prototype.hasList = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional bytes d_app_address = 1;
 * @return {string}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.getDAppAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes d_app_address = 1;
 * This is a type-conversion wrapper around `getDAppAddress()`
 * @return {string}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.getDAppAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getDAppAddress()));
};


/**
 * optional bytes d_app_address = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDAppAddress()`
 * @return {!Uint8Array}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.getDAppAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getDAppAddress()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.setDAppAddress = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional string function_name = 2;
 * @return {string}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.getFunctionName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.setFunctionName = function(value) {
  jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * repeated Argument arguments = 3;
 * @return {!Array<!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument>}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.getArgumentsList = function() {
  return /** @type{!Array<!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument, 3));
};


/** @param {!Array<!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument>} value */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.setArgumentsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument=} opt_value
 * @param {number=} opt_index
 * @return {!proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.addArguments = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.zb.events.TransactionMetadata.InvokeScriptMetadata.Argument, opt_index);
};


proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.clearArgumentsList = function() {
  this.setArgumentsList([]);
};


/**
 * repeated zb.Amount payments = 4;
 * @return {!Array<!proto.zb.Amount>}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.getPaymentsList = function() {
  return /** @type{!Array<!proto.zb.Amount>} */ (
    jspb.Message.getRepeatedWrapperField(this, amount_pb.Amount, 4));
};


/** @param {!Array<!proto.zb.Amount>} value */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.setPaymentsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.zb.Amount=} opt_value
 * @param {number=} opt_index
 * @return {!proto.zb.Amount}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.addPayments = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.zb.Amount, opt_index);
};


proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.clearPaymentsList = function() {
  this.setPaymentsList([]);
};


/**
 * optional zb.InvokeScriptResult result = 5;
 * @return {?proto.zb.InvokeScriptResult}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.getResult = function() {
  return /** @type{?proto.zb.InvokeScriptResult} */ (
    jspb.Message.getWrapperField(this, invoke_script_result_pb.InvokeScriptResult, 5));
};


/** @param {?proto.zb.InvokeScriptResult|undefined} value */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.setResult = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.clearResult = function() {
  this.setResult(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.TransactionMetadata.InvokeScriptMetadata.prototype.hasResult = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.zb.events.TransactionMetadata.LeaseMetadata = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.zb.events.TransactionMetadata.LeaseMetadata, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.zb.events.TransactionMetadata.LeaseMetadata.displayName = 'proto.zb.events.TransactionMetadata.LeaseMetadata';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.zb.events.TransactionMetadata.LeaseMetadata.prototype.toObject = function(opt_includeInstance) {
  return proto.zb.events.TransactionMetadata.LeaseMetadata.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.zb.events.TransactionMetadata.LeaseMetadata} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.LeaseMetadata.toObject = function(includeInstance, msg) {
  var f, obj = {
    recipientAddress: msg.getRecipientAddress_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.zb.events.TransactionMetadata.LeaseMetadata}
 */
proto.zb.events.TransactionMetadata.LeaseMetadata.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.zb.events.TransactionMetadata.LeaseMetadata;
  return proto.zb.events.TransactionMetadata.LeaseMetadata.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.zb.events.TransactionMetadata.LeaseMetadata} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.zb.events.TransactionMetadata.LeaseMetadata}
 */
proto.zb.events.TransactionMetadata.LeaseMetadata.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRecipientAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.zb.events.TransactionMetadata.LeaseMetadata.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.zb.events.TransactionMetadata.LeaseMetadata.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.zb.events.TransactionMetadata.LeaseMetadata} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.zb.events.TransactionMetadata.LeaseMetadata.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRecipientAddress_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes recipient_address = 1;
 * @return {string}
 */
proto.zb.events.TransactionMetadata.LeaseMetadata.prototype.getRecipientAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes recipient_address = 1;
 * This is a type-conversion wrapper around `getRecipientAddress()`
 * @return {string}
 */
proto.zb.events.TransactionMetadata.LeaseMetadata.prototype.getRecipientAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRecipientAddress()));
};


/**
 * optional bytes recipient_address = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRecipientAddress()`
 * @return {!Uint8Array}
 */
proto.zb.events.TransactionMetadata.LeaseMetadata.prototype.getRecipientAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRecipientAddress()));
};


/** @param {!(string|Uint8Array)} value */
proto.zb.events.TransactionMetadata.LeaseMetadata.prototype.setRecipientAddress = function(value) {
  jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional TransferMetadata transfer = 104;
 * @return {?proto.zb.events.TransactionMetadata.TransferMetadata}
 */
proto.zb.events.TransactionMetadata.prototype.getTransfer = function() {
  return /** @type{?proto.zb.events.TransactionMetadata.TransferMetadata} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.TransactionMetadata.TransferMetadata, 104));
};


/** @param {?proto.zb.events.TransactionMetadata.TransferMetadata|undefined} value */
proto.zb.events.TransactionMetadata.prototype.setTransfer = function(value) {
  jspb.Message.setOneofWrapperField(this, 104, proto.zb.events.TransactionMetadata.oneofGroups_[0], value);
};


proto.zb.events.TransactionMetadata.prototype.clearTransfer = function() {
  this.setTransfer(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.TransactionMetadata.prototype.hasTransfer = function() {
  return jspb.Message.getField(this, 104) != null;
};


/**
 * optional MassTransferMetadata mass_transfer = 111;
 * @return {?proto.zb.events.TransactionMetadata.MassTransferMetadata}
 */
proto.zb.events.TransactionMetadata.prototype.getMassTransfer = function() {
  return /** @type{?proto.zb.events.TransactionMetadata.MassTransferMetadata} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.TransactionMetadata.MassTransferMetadata, 111));
};


/** @param {?proto.zb.events.TransactionMetadata.MassTransferMetadata|undefined} value */
proto.zb.events.TransactionMetadata.prototype.setMassTransfer = function(value) {
  jspb.Message.setOneofWrapperField(this, 111, proto.zb.events.TransactionMetadata.oneofGroups_[0], value);
};


proto.zb.events.TransactionMetadata.prototype.clearMassTransfer = function() {
  this.setMassTransfer(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.TransactionMetadata.prototype.hasMassTransfer = function() {
  return jspb.Message.getField(this, 111) != null;
};


/**
 * optional InvokeScriptMetadata invoke_script = 116;
 * @return {?proto.zb.events.TransactionMetadata.InvokeScriptMetadata}
 */
proto.zb.events.TransactionMetadata.prototype.getInvokeScript = function() {
  return /** @type{?proto.zb.events.TransactionMetadata.InvokeScriptMetadata} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.TransactionMetadata.InvokeScriptMetadata, 116));
};


/** @param {?proto.zb.events.TransactionMetadata.InvokeScriptMetadata|undefined} value */
proto.zb.events.TransactionMetadata.prototype.setInvokeScript = function(value) {
  jspb.Message.setOneofWrapperField(this, 116, proto.zb.events.TransactionMetadata.oneofGroups_[0], value);
};


proto.zb.events.TransactionMetadata.prototype.clearInvokeScript = function() {
  this.setInvokeScript(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.TransactionMetadata.prototype.hasInvokeScript = function() {
  return jspb.Message.getField(this, 116) != null;
};


/**
 * optional LeaseMetadata lease_meta = 117;
 * @return {?proto.zb.events.TransactionMetadata.LeaseMetadata}
 */
proto.zb.events.TransactionMetadata.prototype.getLeaseMeta = function() {
  return /** @type{?proto.zb.events.TransactionMetadata.LeaseMetadata} */ (
    jspb.Message.getWrapperField(this, proto.zb.events.TransactionMetadata.LeaseMetadata, 117));
};


/** @param {?proto.zb.events.TransactionMetadata.LeaseMetadata|undefined} value */
proto.zb.events.TransactionMetadata.prototype.setLeaseMeta = function(value) {
  jspb.Message.setOneofWrapperField(this, 117, proto.zb.events.TransactionMetadata.oneofGroups_[0], value);
};


proto.zb.events.TransactionMetadata.prototype.clearLeaseMeta = function() {
  this.setLeaseMeta(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.zb.events.TransactionMetadata.prototype.hasLeaseMeta = function() {
  return jspb.Message.getField(this, 117) != null;
};


goog.object.extend(exports, proto.zb.events);
